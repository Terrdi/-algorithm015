class Solution {
    private static final long MOD = 1000000007L;

    /**
     * 给定一个正整数 n，返回长度为 n 的所有可被视为可奖励的出勤记录的数量。 答案可能非常大，你只需返回结果mod 10^9 + 7的值。
     *
     * 学生出勤记录是只包含以下三个字符的字符串：
     * 'A' : Absent，缺勤
     * 'L' : Late，迟到
     * 'P' : Present，到场
     * 如果记录不包含多于一个'A'（缺勤）或超过两个连续的'L'（迟到），则该记录被视为可奖励的。
     *
     * 时间复杂度 O(n)
     * 空间复杂度 O(n)
     * @param n
     * @return
     */
    public int checkRecord(int n) {
        long[][] dp = new long[n][7];
        // 0 - 没有缺勤且这一个是到场
        // 1 - 没有缺勤且这一个是迟到并且上一个不是迟到
        // 2 - 没有缺勤且这一个是迟到并且上一个是迟到 & 上上一个不是迟到
        // 3 - 有缺勤且这一个是到场
        // 4 - 有缺勤且这一个是迟到并且上一个不是迟到
        // 5 - 有缺勤且这一个是迟到并且上一个是迟到 & 上上一个不是迟到
        // 6 - 这一个是缺勤
        Arrays.fill(dp[0], 0);
        dp[0][0] = dp[0][1] = dp[0][6] = 1;
        for (int i = 1;i < n;i++) {
            // dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
            // dp[i][1] = dp[i - 1][0] + dp[i - 1][1] - (i > 1 ? dp[i - 2][1] : 0);
            // dp[i][2] = dp[i - 1][2] + dp[i - 1][3] + dp[i - 1][4];
            // dp[i][3] = dp[i - 1][2] + dp[i - 1][4] + dp[i - 1][3] - (i > 1 ? dp[i - 2][3] : 0);
            // dp[i][4] = dp[i - 1][0] + dp[i - 1][1];
            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD;
            dp[i][1] = dp[i - 1][0];
            dp[i][2] = dp[i - 1][1];
            dp[i][3] = (dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][5] + dp[i - 1][6]) % MOD;
            dp[i][4] = (dp[i - 1][3] + dp[i - 1][6]) % MOD;
            dp[i][5] = dp[i - 1][4];
            dp[i][6] = dp[i][0];
        }
        n--;

        return Long.valueOf((dp[n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4] + dp[n][5] + dp[n][6]) % MOD).intValue();
    }
}