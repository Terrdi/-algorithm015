# 毕业总结
### 常用的数据结构
|操作|查找|修改|删除|找最小/最大值|删除最小/最大值|插入一个节点|根据key删除结点|合并|
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 数组 | O(1) | O(1) | O(n) | O(n) | O(n) | O(n) | --- | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(n) | O(n) | O(1) | --- | O(1) |
| 跳表 | O(log n) | O(log n) | O(log n) | O(1)/O(log n) | O(log n) | O(log n) | --- | O(n * log n) |
| 栈 | O(n) | O(n) | O(1) | O(n) | O(n) | O(1) | --- | O(n) |
| 队列 | O(n) | O(n) | O(1) | O(n) | O(n) | O(1) | --- | O(n) |
| 哈希表 | O(1) | O(1) | O(1) | O(n) | O(n) | O(1) | O(1) | O(n) |
| 树 | O(n) | O(1) | O(n) | O(n) | O(n) | O(1) | --- | O(1) |
| 二叉树 | O(n) | O(1) | O(n) | O(n) | O(n) | O(logn) | --- | O(logn) |
| 二叉排序树 | O(log n) | O(log n) | O(log n) | O(log n) | O(log n) | O(log n) | --- | O(log n) |
| 红黑树 | O(log n) | O(log n) | O(log n) | O(log n) | O(log n) | O(log n) | --- | O(log n) |
| 图 | O(n) | O(1) | O(1) | O(n) | O(n) | O(1) | --- | O(1) |
| 并查集 | O(n) | O(1) | O(1) | O(n) | O(n) | O(1) | --- | O(1) |
| Trie树 | O(n) | O(n) | O(n) | --- | --- | O(n) | O(n) | O(n) |
| 布隆过滤器 | O(1)/不严格 | --- | --- | --- | --- | O(1) | --- | O(1) |
| 二叉堆 | O(log n) | O(log n) | O(log n) | O(1) | O(log n) | O(log n) | O(log n) | O(n) |
| 斐波那契堆 | O(log n) | O(log n) | O(log n) | O(1) | O(log n) | O(1) | O(1) | O (1) |
| 严格斐波那契堆 | O(log n) | O(log n) | O(log n) | O(1) | O(log n) | O(1) | O(1) | O (1) |

### 常用的算法
* 回溯算法 --- 通过递归穷举所有可能性
* 分治算法 --- 将大问题拆分成具有相同性质的子问题，并计算出结果然后进行合并
* 动态规划 --- 采用记忆化搜索的方式, 先求得最简子问题的解，再通过子问题的较简子问题递推出最终子问题的解
* 贪心算法 --- 通过局部最优解扩展到全局最优解


### 感想
* 对常用的数据结构理解更加深了一层
* 对常用的算法有了基本认识, 尤其对动态规划有了更加系统的理解
* 感谢覃超老师、各个助教以及班主任在这段时间的辛苦付出
* 感谢覃超老师的五步刷题法，提高了我的学习效率
